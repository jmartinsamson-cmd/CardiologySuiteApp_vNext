#!/usr/bin/env node
/* eslint-disable no-console */
import process from 'node:process';
import express from 'express';
import { fetch } from 'undici';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { ListToolsRequestSchema, CallToolRequestSchema } from '@modelcontextprotocol/sdk/types.js';

// Proxy target: your ai-search backend
const BASE_URL = process.env.AI_SEARCH_BASE_URL || 'http://localhost:8081';
// Mode: 'stdio' (default, for VS Code Copilot) or 'http' (SSE HTTP server)
const MODE = (process.env.MCP_MODE || 'stdio').toLowerCase();
// HTTP SSE settings (for MODE=http)
const PORT = Number(process.env.MCP_HTTP_PORT || 8091);
const SSE_PATH = process.env.MCP_SSE_PATH || '/mcp/sse';
const POST_PATH = process.env.MCP_POST_PATH || '/mcp/messages';

async function doFetch(path, opts = {}) {
  const url = path.startsWith('http') ? path : `${BASE_URL}${path}`;
  const res = await fetch(url, {
    ...opts,
    headers: {
      'content-type': 'application/json',
      ...(opts.headers || {}),
    },
  });
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`HTTP ${res.status} ${res.statusText}: ${text?.slice(0, 500)}`);
  }
  const ct = res.headers.get('content-type') || '';
  if (ct.includes('application/json')) return res.json();
  return res.text();
}

function buildServer() {
  const server = new Server({ name: 'ai-search', version: '0.4.0' }, { capabilities: { tools: {} } });
  server.setRequestHandler(ListToolsRequestSchema, async () => ({
    tools: [
      {
        name: 'querySearchIndex',
        description: 'Query the Azure AI Search index for cardiology content. Returns normalized hits.',
        input_schema: {
          type: 'object', additionalProperties: false,
          properties: {
            query: { type: 'string' },
            top: { type: 'number' },
            filters: { type: 'string' },
            select: { type: 'array', items: { type: 'string' } },
          }, required: ['query']
        },
      },
      {
        name: 'analyzeText',
        description: 'Analyze a clinical note. Returns Assessment, Plan, citations, and meta.',
        input_schema: {
          type: 'object', additionalProperties: false,
          properties: { note: { type: 'string' } }, required: ['note']
        },
      },
      {
        name: 'parseAzureNote',
        description: 'Summarize and parse a cardiology note stored in Azure Blob Storage using GPT refinement.',
        input_schema: {
          type: 'object', additionalProperties: false,
          properties: { container: { type: 'string' }, blob: { type: 'string' } },
          required: ['container', 'blob']
        },
      },
      {
        name: 'medicalQA',
        description: 'Answer medical questions using RAG from indexed cardiology guidelines (Prompty pattern). Returns evidence-based answer with citations.',
        input_schema: {
          type: 'object', additionalProperties: false,
          properties: {
            question: { type: 'string', description: 'The medical question to answer' },
            maxSources: { type: 'number', description: 'Maximum guideline sources to retrieve (1-10, default 5)' },
            temperature: { type: 'number', description: 'GPT temperature 0-1 (default 0.2)' },
          },
          required: ['question']
        },
      },
    ],
  }));

  server.setRequestHandler(CallToolRequestSchema, async (req) => {
    const name = req.params?.name;
    const args = /** @type {any} */ (req.params?.arguments) || {};

    if (name === 'querySearchIndex') {
      const q = String(args.query || '').trim();
      if (!q) return { content: [{ type: 'text', text: 'Error: query is required' }] };
      const top = Number.isFinite(args.top) ? Math.min(50, Math.max(1, Number(args.top))) : 10;
      const filters = args.filters ? String(args.filters) : undefined;
      const select = Array.isArray(args.select) ? args.select.filter(s => typeof s === 'string') : undefined;
      const body = { q, top, skip: 0, select, filters };
      const json = await doFetch('/search', { method: 'POST', body: JSON.stringify(body) });
      const summary = { ok: !!json?.ok, count: json?.count ?? (json?.results?.length || 0), fields: select };
      return { content: [ { type: 'text', text: `querySearchIndex results for "${q}" (top ${top}): ${summary.count}` }, { type: 'text', text: JSON.stringify(json, null, 2) } ] };
    }

    if (name === 'analyzeText') {
      const note = String(args.note || '').trim();
      if (!note) return { content: [{ type: 'text', text: 'Error: note is required' }] };
      const json = await doFetch('/api/analyze-note', { method: 'POST', body: JSON.stringify({ note }) });
      return { content: [ { type: 'text', text: 'Assessment and Plan generated by ai-search backend:' }, { type: 'text', text: JSON.stringify(json, null, 2) } ] };
    }

    if (name === 'parseAzureNote') {
      const container = String(args.container || '').trim();
      const blob = String(args.blob || '').trim();
      if (!container || !blob) return { content: [{ type: 'text', text: 'Error: container and blob are required' }] };
      const json = await doFetch('/parse', { method: 'POST', body: JSON.stringify({ container, blob }) });
      return { content: [ { type: 'text', text: `parseAzureNote for ${container}/${blob}` }, { type: 'text', text: JSON.stringify(json, null, 2) } ] };
    }

    if (name === 'medicalQA') {
      const question = String(args.question || '').trim();
      if (!question) return { content: [{ type: 'text', text: 'Error: question is required' }] };
      const maxSources = args.maxSources !== undefined ? Number(args.maxSources) : undefined;
      const temperature = args.temperature !== undefined ? Number(args.temperature) : undefined;
      const body = { question, maxSources, temperature };
      const json = await doFetch('/api/medical-qa', { method: 'POST', body: JSON.stringify(body) });
      const confidence = json.confidence ? `${(json.confidence * 100).toFixed(1)}%` : 'N/A';
      const sourcesText = json.sources?.map((s, i) => `${i + 1}. ${s.title} (score: ${s.score?.toFixed(2)})`).join('\n') || 'No sources';
      return { content: [
        { type: 'text', text: `Medical Q&A for: "${question}"\nConfidence: ${confidence}\n\n${json.answer}` },
        { type: 'text', text: `\n\nSources:\n${sourcesText}` }
      ] };
    }

    return { content: [{ type: 'text', text: `Unknown tool: ${name}` }] };
  });

  return server;
}

async function main() {
  if (MODE === 'http') {
    const app = express();
    app.use(express.json());
    /** @type {Map<string, import('@modelcontextprotocol/sdk/dist/server/sse.js').SSEServerTransport>} */
    const sessions = new Map();

    app.get('/mcp/health', (_req, res) => res.json({ ok: true, mode: 'sse', post: POST_PATH, sse: SSE_PATH }));

    app.get(SSE_PATH, async (_req, res) => {
      try {
        const transport = new SSEServerTransport(POST_PATH, res);
        const server = buildServer();
        await server.connect(transport);
        sessions.set(transport.sessionId, transport);
      } catch (e) {
        res.status(500).type('text/plain').send(String(e?.message || e));
      }
    });

    app.post(POST_PATH, async (req, res) => {
      const sessionId = String(req.query.sessionId || '').trim();
      const transport = sessionId ? sessions.get(sessionId) : undefined;
      if (!transport) return res.status(404).type('text/plain').send('Unknown or missing session');
      await transport.handlePostMessage(req, res);
    });

    app.listen(PORT, () => {
      console.log(`[mcp] HTTP SSE server listening on http://localhost:${PORT}${SSE_PATH}`);
      console.log(`[mcp] Proxying backend at ${BASE_URL}`);
    });
  } else {
    // stdio mode for Copilot Chat
    const server = buildServer();
    const transport = new StdioServerTransport();
    await server.connect(transport);
    // Process will stay alive awaiting stdio from Copilot
  }
}

main().catch(err => {
  // Log error message only, not stack trace to prevent information exposure
  console.error('[mcp] Fatal error:', err?.message || String(err));
  process.exit(1);
});
 
